<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Sakura</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width,hight=device-hight,minimum-scale=1.0,maximum-scale=1.0,ser-scalable=none"/>
<script type="text/javascript" src="js/three.js"></script>
<script type="text/javascript" src="js/app.js"></script>
</head>
<body id="body" bgcolor="black" onLoad="init()">
<script type="text/javascript">
    var SCREEN_WIDTH = window.innerWidth;
    var SCREEN_HEIGHT = window.innerHeight;
    var container;
    var particle;

    var camera;
    var scene;
    var renderer;

    var starSnow = 1;

    var particles = [];

    var particleImage = new Image();
    particleImage.src = 'images/sakura.png';

    function init() {
        // container 画布实例
        container = document.createElement('div');
        document.body.appendChild(container);

        // 透视投影照相机
        camera = new THREE.PerspectiveCamera(30, SCREEN_WIDTH/SCREEN_HEIGHT, 1, 10000);
        // 照相机的位置
        camera.position.set(0, 0, 1000);

        scene = new THREE.Scene();
        scene.add(camera);

        renderer = new THREE.CanvasRenderer();
        renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        var material = new THREE.ParticleBasicMaterial({
            map: new THREE.Texture(particleImage)
        });
        for (var i = 0; i < 32; i++) {
            particle = new Particle3D(material);
            // 正负屏幕宽度 注意半屏宽 !!!
            particle.position.x = (Math.random() - 0.5) * SCREEN_WIDTH;
            particle.position.y = (Math.random() - 0.5) * SCREEN_HEIGHT;
            // particle.position.x = 0
            // particle.position.y = 0
            // Z 轴距离
            particle.position.z = Math.random() * 10000;
            particle.scale.x = particle.scale.y = 1;
            console.log(particle.rotation)
            scene.add(particle);
            particles.push(particle);
        }

        container.appendChild(renderer.domElement);

        // 捕捉鼠标事件
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        // document.addEventListener('mousedown', onDocumentTouchStart,false);
        // document.addEventListener('mousemove', onDocumentTouchMove, false);
        // document.addEventListener('mouseup', onDocumentTouchEnd,false);
        // 捕捉触摸事件
        document.addEventListener('touchstart', onDocumentTouchStart, false);
        document.addEventListener('touchmove', onDocumentTouchMove, false);
        document.addEventListener('touchend', onDocumentTouchEnd, false);

        // 一秒 24 帧
        setInterval(loop, 1000/24);
        // requestAnimationFrame(loop);
    }

    var mouseStartX = 0;
    var mouseFlag = 0;

    function onDocumentMouseMove(event) {
        var direction = event.pageX - mouseStartX;
        mouseStartX = event.pageX;
        if(direction>0) {
            // mouseStartX = event.pageX;
            mouseFlag = 1;
        }else if (direction<0) {
            // mouseStartX = event.pageX;
            mouseFlag = -1;
        }
        callback(mouseFlag);
    }


    var touchStartX;
    //储存当前是否滑动的状态
    var touchFlag = 0;
    //检测滑动的灵敏度
    var touchSensitive = 80;

    function onDocumentTouchStart(event) {

        if(event.touches.length==1) {
            //取消默认关联动作;
            event.preventDefault();
            touchStartX = event.touches[0].pageX;
        }
    }


    function onDocumentTouchMove(event) {

        if (event.touches.length == 1) {
            event.preventDefault();
            var direction = event.touches[0].pageX - touchStartX;
            if (Math.abs(direction) > touchSensitive) {
                if(direction>0) {
                    touchFlag = 1;
                }else if(direction<0) {
                    touchFlag = -1;
                }
            }
        }

    }

    function onDocumentTouchEnd(event) {
        // var direction = event.changedTouches[0].pageX - touchStartX;
        callback(touchFlag);
    }


    function callback(touchFlag) {
        var speedX = 25 * touchFlag;
        touchFlag = 0;
        for (var i = 0; i < particles.length; i++) {
            particles[i].velocity = new THREE.Vector3(speedX, -10, 0);
        }
        var timeOut = setTimeout(";", 800);
        clearTimeout(timeOut);

        var clearI = setInterval(function() {
            if (touchFlag) {
                clearInterval(clearI);
                return;
            };
            speedX *= 0.8;
            if (Math.abs(speedX)<=1.5) {
                speedX = 0;
                clearInterval(clearI);
            };
            for (var i = 0; i < particles.length; i++) {
                particles[i].velocity = new THREE.Vector3(speedX,-10,0);
            }
        }, 100);
    }


    function loop() {

        for(var i = 0; i<particles.length; i++) {

            var particle = particles[i];
            particle.updatePhysics();

            with(particle.position) {
                if((y<-SCREEN_HEIGHT) && starSnow) {
                    y += 2 * SCREEN_HEIGHT;
                }

                if(x>SCREEN_WIDTH) {
                    x -= 2 * SCREEN_WIDTH;
                }else if(x<-1000) {
                    x += 2 * SCREEN_WIDTH;
                }
                if(z>1000) {
                  z -= 2000;
                }else if(z<-1000){
                  z += 2000;
                }
            }
        }

        camera.lookAt(scene.position);
        renderer.render(scene, camera);
        // requestAnimationFrame(loop);
    }
</script>
</body>
</html>
